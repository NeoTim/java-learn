{"./":{"url":"./","title":"前言","keywords":"","body":"Java 学习笔记 Java 8 in action Java 7 Concurrency Cookbook Pro Java 7 NIO.2 Java 7 New Features Cookbook "},"java8/lambda.html":{"url":"java8/lambda.html","title":"Lambda","keywords":"","body":"Lambda 表达式 定义 Lambda 形式 函数式接口 类型检查 类型推断 Java 8 中的函数式接口 Predicate BiPredicate Consumer BiConsumer Supplier Function UnaryOperator BiFunction BinaryOperator Primitive specializations 定义 Lambda(λ) 表达式是一种在 被调用的位置 或者 作为参数传递给函数的位置 定义匿名函数对象 的简便方法。下面是关于 Lambda 表达式的几个点： 匿名（Anonymous） - 不像其他普通方法那样具有名字 函数（Function） - Lambda 表达式不像普通方法那样属于某个特定的类，它是独立于类存在的。但是和方法一样，Lambda 表达式有参数列表、函数主体和返回值，还可能有可以抛出的异常列表。 传递（Passed around）- Lambda 表达式可以作为参数传递给方法或者存储在变量中。 简洁（Concise）- 无需像匿名类那样写很多的模板代码。 下面是一个示例 @FunctionalInterface interface Calculator { int cal(int a, int b); } public class HelloWorld { public static void main(String[] args) { Calculator c = (a, b) -> a + b; System.out.println(c.cal(1, 2)); c = (a, b) -> a * b; System.out.println(c.cal(1, 2)); } } Lambda 形式 Lambda 表达式的基本形式如下所示： (argument list) -> code 下面是一个例子： 如上所示： Lambda 表达式包含三个部分： 参数列表（A list of parameters） - 上图中为 (Apple a1, Apple a2) 箭头（An arrow） - 把参数列表和 Lambda 主体分隔开 Lambda 主体（The body of the lambda） - 上图中为 a1.getWeight().compareTo(a2.getWeight())，该 Lambda 主体会返回 compareTo 的结果。 Lambda 函数的主体可以是表达式（expression）或者语句（statement），所以 Lambda 函数返回值有下面两种情况： 如果 Lambda 主体为表达式，那么 Lambda 函数的返回值就是表达式的计算值 如果 Lambda 主体为语句，那么 Lambda 返回值就是语句的返回值 关于语句和表达式的区别，可以参考 这篇文章，这里简单说一下：假设有一条语句 int c = a + b;，那么表达式就是指 c = a + b，即不包含 int 和 ;，每个表达式都会有一个计算值（void 也算一种特殊的计算值）。 所以细分一下，Lambda 表达式有两种形式： (parameters) -> expression 和（使用大括号） (parameters) -> {statements} 下面是 Lambda 表达式的几个例子： 使用场景 使用示例 boolean 表达式 (List list) -> list.isEmpty() 创建对象 () -> new Apple(10) Consuming from an object (Apple a) -> { System.out.println(a.getWeight()); } Select/extract from an object (String s) -> s.length() 合并两个值 (int a, int b) -> a * b 比较两个对象 (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()) 函数式接口 我们可以在函数式接口 （Functional interface）中使用 Lambda 表达式。简单来说，函数式接口就是只定义一个抽象方法的接口（接口中可以包含额外的 default 方法）。例如 Comparator 和 Runnable 都是函数式接口： public interface Comparator { int compare(T o1, T o2); } public interface Runnable { void run(); } 我们一般在接口定义中加上 @FunctionalInterface 注解来声明该接口是一个函数式接口。例如下面的形式： @FunctionalInterface public interface Function { R apply(T t); } 当一个接口通过 FunctionalInterface 被声明为函数式接口时，编译器将会检查接口的合法性，如果接口不合法，会报编译错误。 现在考虑一个问题，Lambda 表达式是如何匹配函数式接口的呢？假设我们有一个如下定义的函数式接口： @FunctionalInterface interface Calculator { int cal(int a, int b); } 下面是使用 lambda 表达式以及匿名类来创建 Calculator 对象的示例代码。在下面的代码中对象 c 和 c2 的实现是等价的。 public void demo() { Calculator c = (int a, int b) -> a + b; Calculator c2 = new Calculator() { @Override public int cal(int a, int b) { return a + b; } }; } 从上面的例子中，我们可以看到 Lambda 表达式 是和函数式接口中的 抽象方法 进行匹配的，其中 Lambda 表达式中参数匹配 cal 方法的参数，Lambda body 的内容作为抽象方法的具体实现，Lambda body 的计算值作为方法的返回值。这也是为什么要求函数式接口只能有一个抽象方法的原因。 函数式接口中抽象方法的签名（signature）描述了 Lambda 表达式的签名，因为 Lambda 表达式并没有名字，所以这里的签名只关注三个方面：方法参数 、返回值 以及 异常声明。我们将抽象方法所描述的 Lambda 形式称为函数描述符（function descriptor）。在 Calculator 类中，cal 方法对应的函数描述符为 (int, int) -> int，即接受两个 int 类型作为参数，表达式的计算值为 int 类型。所以下面的 Lambda 表达式都是合法的： (int a, int b) -> a (int a, int b) -> a + b (int a, int b) -> 0 如果 Lambda 表达式抛出一个可检查异常，那么对应的抽象方法所声明的 throws 语句也要与之匹配。看下面的一个例子： @FunctionalInterface interface ThrowExceptionInterface { void run(int a, int b); } public class LambdaTest { public void throwException() { // 这里编译时会报 Unhandled Exception：java.io.Exception ThrowExceptionInterface t = (int a, int b) -> { throw new IOException(); }; } } 其实也很好理解，Lambda body 中的内容会作为抽象方法的具体实现，在方法中抛出了异常但是方法声明中却没有相关的异常声明，编译器肯定要报错的。 另外还有一个特殊的 void 兼容规则。如果抽象方法的返回值为 void，即对应的函数描述符为 (T) -> void，那么对于 body 为 语句表达式（statement expression） 的 Lambda 表达式，只要求参数列表匹配即可。看下面的例子： @FunctionalInterface interface VoidInterface { void run(int a); } public class LambdaTest { public static void voidTest() { List list = new ArrayList<>(); // 这里 a++ 返回一个 int，但是和 void 兼容 VoidInterface v = (int a) -> a++; // 下面的代码会报错，因为 a-1 不是一个语句表达式 v = (int a) -> a-1; } } 这里说一下语句表达式: The term “statement expression” or “expression statement” refers to expressions that are also allowed to be used as a statement. 语法表达式有下面四类： Assignment expressions Any use of ++ or -- Method invocations Object creation expressions 类型检查 Lambda 表达式本身并不包含它是实现哪个函数式接口的信息，编译器会根据 Lambda 表达式所处的上下文（context）环境来推断 Lambda 表达式的目标类型（target type），例如对于下面的代码： Calculator c = (int a, int b) -> a + b; Lambda 表达式会赋值给 Calculator 对象，那么该 Lambda 表达式对应的目标类型就是 Calculator 接口，该接口中的 cal 方法对应的函数描述符为 (int, int) -> int，这个和 (int a, int b) -> a + b 可以匹配，这样就完成了类型检查。下图是一个完整的例子： 类型推断 在上面我们提到编译器会根据上下文环境推断出与 Lambda 表达式对应的函数式接口，这意味着编译器同样可以根据接口中抽象方法的函数函数描述符推断出 Lambda 表达式的签名，这样编译器就可以知道 Lambda 表达式的参数类型，这样就可以省略 Lambda 表达式中的参数类型， Calculator c = (a, b) -> a + b; // 当只有一个参数时，可以省略掉 () VoidInterface v = a -> a++; Java 8 中的函数式接口 在 Java 8 中定义了一些函数式接口，位于 java.util.function 包下，下面是这些接口的总览： +--- BiConsumer.java +--- BiFunction.java +--- BinaryOperator.java +--- BiPredicate.java +--- BooleanSupplier.java +--- Consumer.java +--- DoubleBinaryOperator.java +--- DoubleConsumer.java +--- DoubleFunction.java +--- DoublePredicate.java +--- DoubleSupplier.java +--- DoubleToIntFunction.java +--- DoubleToLongFunction.java +--- DoubleUnaryOperator.java +--- Function.java +--- IntBinaryOperator.java +--- IntConsumer.java +--- IntFunction.java +--- IntPredicate.java +--- IntSupplier.java +--- IntToDoubleFunction.java +--- IntToLongFunction.java +--- IntUnaryOperator.java +--- LongBinaryOperator.java +--- LongConsumer.java +--- LongFunction.java +--- LongPredicate.java +--- LongSupplier.java +--- LongToDoubleFunction.java +--- LongToIntFunction.java +--- LongUnaryOperator.java +--- ObjDoubleConsumer.java +--- ObjIntConsumer.java +--- ObjLongConsumer.java +--- Predicate.java +--- Supplier.java +--- ToDoubleBiFunction.java +--- ToDoubleFunction.java +--- ToIntBiFunction.java +--- ToIntFunction.java +--- ToLongBiFunction.java +--- ToLongFunction.java +--- UnaryOperator.java Predicate 用来测试对象是否满足某种条件。该接口定义了一个 test 方法，接受一个泛型对象（T），并返回测试结果（boolean），函数描述符为 T -> boolean。下面是一个使用示例： public boolean judge(T t, Predicate p) { return p.test(t); } public void testPredicate() { String text = \"111\"; System.out.println(judge(text, s -> s != null)); } 下面是 Predicate 接口的实现： /** * Represents a predicate (boolean-valued function) of one argument. */ @FunctionalInterface public interface Predicate { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return true if the input argument matches the predicate, * otherwise false */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is false, then the other * predicate is not evaluated. */ default Predicate and(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } /** * Returns a predicate that represents the logical negation of this * predicate. */ default Predicate negate() { return (t) -> !test(t); } /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is true, then the other * predicate is not evaluated. */ default Predicate or(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. */ static Predicate isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } 我们看到在 Predicate 类中，除了 test 方法，还定义了三个 default 方法，and, or 和 negate，它们分别对应逻辑运算中的与（&&）、或（||）、非（!）操作。通过这三个方法，我们可以构造更复杂的 predicate 表达式： public void testPredicate() { String text = \"111\"; Predicate a = s - > s != null; Predicate b = s - > s.length() > 3; System.out.println(judge(text, a.and(b))); System.out.println(judge(text, a.negate())); System.out.println(judge(text, a.or(b))); } 对应的输出结果为： false false true 另外 and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此 a.or(b).and(c) 可以看作 (a || b) && c。 BiPredicate BiPredicate 针对两个参数对象（T, U）进行测试，函数描述符为 (T, U) -> boolean。下面是该接口的定义： /** * Represents a predicate (boolean-valued function) of two arguments. This is * the two-arity specialization of {@link Predicate}. */ @FunctionalInterface public interface BiPredicate { boolean test(T t, U u); default BiPredicate and(BiPredicate other) { Objects.requireNonNull(other); return (T t, U u) -> test(t, u) && other.test(t, u); } default BiPredicate negate() { return (T t, U u) -> !test(t, u); } default BiPredicate or(BiPredicate other) { Objects.requireNonNull(other); return (T t, U u) -> test(t, u) || other.test(t, u); } } 下面是一个使用示例： public void testBiPredicate() { BiPredicate b = (x, y) -> x > 0 && y > 3; boolean r = b.test(1, 4); System.out.println(r); } Consumer Consumer（消费者），针对对象进行某种操作（消费对象）。该接口定义了一个 accept 方法，会将该方法作用于目标对象，函数描述符为 T -> void。下面是使用示例： public void consume(T t, Consumer c) { c.accept(t); } @Test public void testConsume() { String text = \"1234\"; consume(text, s -> System.out.println(s.substring(2))); } 下面是 Consumer 类的代码 /** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, Consumer is expected * to operate via side-effects. */ @FunctionalInterface public interface Consumer { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed Consumer that performs, in sequence, this * operation followed by the after operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the after operation will not be performed. */ default Consumer andThen(Consumer after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } Consumer 中定义了一个 andThen 的 default 方法，通过该方法我们可以对目标对象进行链式（chain）处理，下面是一个示例： public void testConsume() { StringBuilder builder = new StringBuilder(); Consumer a = s -> s.append(\"abcd\"); Consumer b = s -> s.reverse(); Consumer c = s -> s.append(\"1234\"); consume(builder, a.andThen(b).andThen(c)); System.out.println(builder.toString()); } 输出结果为： dcba1234 BiConsumer BiConsumer 针对两个对象（T, U）进行操作，对应的函数描述符为 (T, U) -> void。下面是该接口的定义： /** * Represents an operation that accepts two input arguments and returns no * result. This is the two-arity specialization of Consumer. * Unlike most other functional interfaces, BiConsumer is expected * to operate via side-effects. */ @FunctionalInterface public interface BiConsumer { void accept(T t, U u); default BiConsumer andThen(BiConsumer after) { Objects.requireNonNull(after); return (l, r) -> { accept(l, r); after.accept(l, r); }; } } 下面是一个例子： public void testBiConsumer() { BiConsumer b = (x, y) -> System.out.println(x + y); b.accept(\"111\", \"222\"); } Supplier Supplier（供应商），返回一个泛型对象（生产对象）。该接口中定义了一个 get 方法，没有方法参数，返回值是一个泛型对象，函数描述符为 () -> T。下面是一个使用示例 public T supplier(Supplier s) { return s.get(); } public void testSupplier() { String text = supplier(() -> \"1111\"); System.out.println(text); } 下面是 Supplier 接口的定义： /** * Represents a supplier of results. */ @FunctionalInterface public interface Supplier { /** * Gets a result. */ T get(); } Function Function 接口就相当于 y=f(x) 中的函数 f，接收一个 x（argument）返回计算值 y（result）。该接口定义了一个 apply 方法，接收一个 T 类型的对象，返回一个 R 类型的结果，函数描述符为 T -> R。下面是一个使用示例： public R func(T t, Function f) { return f.apply(t); } public void testFunction() { String text = \"1234\"; int i = func(text, t -> Integer.parseInt(t)); // 输出 1235 System.out.println(i + 1); } 下面是 Function 接口的定义： /** * Represents a function that accepts one argument and produces a result. */ @FunctionalInterface public interface Function { /** * Applies this function to the given argument. */ R apply(T t); /** * Returns a composed function that first applies the before * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default Function compose(Function before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the after function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default Function andThen(Function after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } /** * Returns a function that always returns its input argument. */ static Function identity() { return t -> t; } } 在 Function 接口中定义了两个 default 方法：compose 和 andThen 可以进行链式的调用，假设有两个函数 f(x) 和 g(x): f.compose(g) => f(g(x)) f.andThen(g) => g(f(x)) 下图是一个详细的解释 下面是一个使用示例： public void testFunction() { Function f = x -> x + 1; Function g = x -> x * 2; int i = func(1, f.andThen(g)); // 输出 4 System.out.println(i); i = func(1, f.compose(g)); // 输出 3 System.out.println(i); } UnaryOperator UnaryOperator 是一种特殊的 Function，表示操作数和返回值是同一种类型，函数描述符为 T -> T。下面是该接口的定义： /** * Represents an operation on a single operand that produces a result of the * same type as its operand. This is a specialization of {@code Function} for * the case where the operand and result are of the same type. */ @FunctionalInterface public interface UnaryOperator extends Function { /** * Returns a unary operator that always returns its input argument. */ static UnaryOperator identity() { return t -> t; } } 下面是一个使用示例： public void testUnaryOperator() { UnaryOperator u = x -> x + 1; System.out.println(u.apply(1)); } BiFunction BiFunction 接收两个参数（T, U），返回一个结果（R），类似于 z=f(x, y)，对应的函数描述符为 (T, U) -> R。下面是该接口的具体实现： /** * Represents a function that accepts two arguments and produces a result. * This is the two-arity specialization of Function. */ @FunctionalInterface public interface BiFunction { /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u); /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default BiFunction andThen(Function after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } } 下面是一个使用示例： public void testBiFunction() { BiFunction b = (i, d) -> String.valueOf(i + d); String r = b.apply(1, 2.5); System.out.println(r); } BinaryOperator BinaryOperator 是一种特殊的 BiFunction，表示接收的参数和返回的结果都是同一种类型 T，函数描述符为 (T, T) -> T。下面是该接口的定义： /** * Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * BiFunction for the case where the operands and the result are all of * the same type. */ @FunctionalInterface public interface BinaryOperator extends BiFunction { /** * Returns a BinaryOperator which returns the lesser of two elements * according to the specified Comparator. */ public static BinaryOperator minBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) BinaryOperator maxBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } 下面是一个使用示例: public void testBinaryOperator() { BinaryOperator b = (x, y) -> x + y; int z = b.apply(1, 3); System.out.println(z); BinaryOperator min = BinaryOperator.minBy((x, y) -> x - y); // 输出 1 z = min.apply(1, 3); System.out.println(z); // 输出 3 BinaryOperator max = BinaryOperator.maxBy((x, y) -> x - y); z = max.apply(1, 3); System.out.println(z); } Primitive specializations 在上面提到的接口中，都是接受泛型参数，我们知道泛型参数只能是引用类型，也就是说对于 int 这样的基本类型，我们要首先装箱（boxing）成 Integer 类型，在使用的时候再拆箱（unboxing）成 int。虽然 Java 提供了自动装箱机制，但是在性能方面是要付出代价的。所以对于上述的函数式接口，Java 8 提供了针对基本类型的版本，以此来避免输入输出是基本类型时的自动装箱操作。以 Predicate 为例，假设我们要检测一个 int 是否满足某个条件，我们可以使用 IntPredicate ： public void testIntPredicate() { IntPredicate ip = x -> x > 3; boolean r = ip.test(4); System.out.println(r); } 下面是 IntPredicate 的定义，我们可以看到它将泛型 T 改为了基本类型 int。 /** * Represents a predicate (boolean-valued function) of one {@code int}-valued * argument. This is the {@code int}-consuming primitive type specialization of * {@link Predicate}. */ @FunctionalInterface public interface IntPredicate { boolean test(int value); default IntPredicate and(IntPredicate other) { Objects.requireNonNull(other); return (value) -> test(value) && other.test(value); } default IntPredicate negate() { return (value) -> !test(value); } default IntPredicate or(IntPredicate other) { Objects.requireNonNull(other); return (value) -> test(value) || other.test(value); } } 下表列出了 Java 8 中的函数式接口以及其对应的基本类型版本： 函数式接口 函数描述符 基本类型版本 Predicate T -> boolean IntPredicate, LongPredicate, DoublePredicate BiPredicate (L, R) -> boolean Consumer T -> void IntConsumer, LongConsumer, DoubleConsumer BiConsumer (T, U) -> void ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer Supplier () -> T BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier Function T -> R IntFunction, IntToDoubleFunction, IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunction UnaryOperator T -> T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BiFunction (T, U) -> R ToIntBiFunction, ToLongBiFunction, ToDoubleBiFunction BinaryOperator (T, T) -> T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator "},"java8/方法引用.html":{"url":"java8/方法引用.html","title":"方法引用","keywords":"","body":"方法引用 HelloWorld 方法引用形式 实例方法引用 构造方法引用 HelloWorld 方法引用实际上就是根据已有的方法实现来创建 Lambda 表达式。方法引用通过 :: 来使用，下面是一个基本的示例： import org.junit.Test; import java.util.function.IntUnaryOperator; public class HelloWorld { public void increase(int i, IntUnaryOperator o) { System.out.println(o.applyAsInt(i)); } @Test public void testMethod() { IntUnaryOperator operator = Adder::addOne; System.out.println(operator.applyAsInt(1)); } } class Adder { public static int addOne(int i) { return i + 1; } } 方法引用形式 方法引用主要有下面四种形式： 类名::静态方法，例如 Integer::parseInt。 类名::实例方法，例如 String::length，这里有个限制，就是方法接受的第一个参数类型必须是该实例类。 对象::实例方法，例如有一个 String 类型 text，那么就可以写作 text::length。 类名::new，构造方法引用 其实上面的四种形式也可以归纳为三种，静态方法引用，实例方法引用以及构造方法引用，静态方法的方法引用很简单，就是 类名::方法名，只需要保证参数列表和返回值一致即可。下面主要来说下实例方法和构造方法引用。 实例方法引用 实例方法引用有两种形式： 类名::实例方法 对象::实例方法 这两种形式可能有些迷惑，我们首先看下下面的代码： import org.junit.Test; import java.util.function.Function; class Person { private String name; public Person() { } public Person(String name) { this.name = name; } public String getName() { return name; } public String mergeName(Person p) { return name + \" \" + p.name; } } public class InstanceMethod { @Test public void run() { Person a = new Person(\"aa\"); Person b = new Person(\"bb\"); // 第一种形式 Function f = Person::getName; String r = f.apply(b); System.out.println(r); // 第二种形式 Function f2 = a::mergeName; r = f2.apply(b); System.out.println(r); } } 下面是两种方式对应的 Lambda 形式 Person::getName --> (Person p) -> p.getName(); a::mergeName --> (Person p) -> a.mergeName(p); 从上面我们可以看出，当使用 类名::实例方法 这种形式时，是由 Lambda 接收的第一个参数来调用这个实例方法的，如果 Lambda 接受多个参数，比如接收 3 个参数，那么第 2 和 第 3 个参数会作为实例方法的参数，这也是为什么要求 Lambda 表达式接收的第一个参数类型必须是该实例类。 构造方法引用 可以使用 类名::new 来构建构造方法引用。下面是一个示例： public class ConstructorMethod { @Test public void run() { // 相当于 Supplier t = () -> new Person(); Supplier s = Person::new; Person p = s.get(); System.out.println(p.getName()); // 相当于 Function t = (name) -> new Person(name); Function f = Person::new; p = f.apply(\"1234\"); System.out.println(p.getName()); } } "}}