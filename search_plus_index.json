{"./":{"url":"./","title":"前言","keywords":"","body":"Java 学习笔记 Java 8 in action Java 7 Concurrency Cookbook Pro Java 7 NIO.2 Java 7 New Features Cookbook "},"java8/lambda.html":{"url":"java8/lambda.html","title":"Lambda","keywords":"","body":"Lambda 表达式 定义 Lambda 形式 函数式接口 类型检查 类型推断 Java 8 中的函数式接口 Predicate BiPredicate Consumer BiConsumer Supplier Function UnaryOperator BiFunction BinaryOperator Primitive specializations 定义 Lambda(λ) 表达式是一种在 被调用的位置 或者 作为参数传递给函数的位置 定义匿名函数对象 的简便方法。下面是关于 Lambda 表达式的几个点： 匿名（Anonymous） - 不像其他普通方法那样具有名字 函数（Function） - Lambda 表达式不像普通方法那样属于某个特定的类，它是独立于类存在的。但是和方法一样，Lambda 表达式有参数列表、函数主体和返回值，还可能有可以抛出的异常列表。 传递（Passed around）- Lambda 表达式可以作为参数传递给方法或者存储在变量中。 简洁（Concise）- 无需像匿名类那样写很多的模板代码。 下面是一个示例 @FunctionalInterface interface Calculator { int cal(int a, int b); } public class HelloWorld { public static void main(String[] args) { Calculator c = (a, b) -> a + b; System.out.println(c.cal(1, 2)); c = (a, b) -> a * b; System.out.println(c.cal(1, 2)); } } Lambda 形式 Lambda 表达式的基本形式如下所示： (argument list) -> code 下面是一个例子： 如上所示： Lambda 表达式包含三个部分： 参数列表（A list of parameters） - 上图中为 (Apple a1, Apple a2) 箭头（An arrow） - 把参数列表和 Lambda 主体分隔开 Lambda 主体（The body of the lambda） - 上图中为 a1.getWeight().compareTo(a2.getWeight())，该 Lambda 主体会返回 compareTo 的结果。 Lambda 函数的主体可以是表达式（expression）或者语句（statement），所以 Lambda 函数返回值有下面两种情况： 如果 Lambda 主体为表达式，那么 Lambda 函数的返回值就是表达式的计算值 如果 Lambda 主体为语句，那么 Lambda 返回值就是语句的返回值 关于语句和表达式的区别，可以参考 这篇文章，这里简单说一下：假设有一条语句 int c = a + b;，那么表达式就是指 c = a + b，即不包含 int 和 ;，每个表达式都会有一个计算值（void 也算一种特殊的计算值）。 所以细分一下，Lambda 表达式有两种形式： (parameters) -> expression 和（使用大括号） (parameters) -> {statements} 下面是 Lambda 表达式的几个例子： 使用场景 使用示例 boolean 表达式 (List list) -> list.isEmpty() 创建对象 () -> new Apple(10) Consuming from an object (Apple a) -> { System.out.println(a.getWeight()); } Select/extract from an object (String s) -> s.length() 合并两个值 (int a, int b) -> a * b 比较两个对象 (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()) 函数式接口 我们可以在函数式接口 （Functional interface）中使用 Lambda 表达式。简单来说，函数式接口就是只定义一个抽象方法的接口（接口中可以包含额外的 default 方法）。例如 Comparator 和 Runnable 都是函数式接口： public interface Comparator { int compare(T o1, T o2); } public interface Runnable { void run(); } 我们一般在接口定义中加上 @FunctionalInterface 注解来声明该接口是一个函数式接口。例如下面的形式： @FunctionalInterface public interface Function { R apply(T t); } 当一个接口通过 FunctionalInterface 被声明为函数式接口时，编译器将会检查接口的合法性，如果接口不合法，会报编译错误。 现在考虑一个问题，Lambda 表达式是如何匹配函数式接口的呢？假设我们有一个如下定义的函数式接口： @FunctionalInterface interface Calculator { int cal(int a, int b); } 下面是使用 lambda 表达式以及匿名类来创建 Calculator 对象的示例代码。在下面的代码中对象 c 和 c2 的实现是等价的。 public void demo() { Calculator c = (int a, int b) -> a + b; Calculator c2 = new Calculator() { @Override public int cal(int a, int b) { return a + b; } }; } 从上面的例子中，我们可以看到 Lambda 表达式 是和函数式接口中的 抽象方法 进行匹配的，其中 Lambda 表达式中参数匹配 cal 方法的参数，Lambda body 的内容作为抽象方法的具体实现，Lambda body 的计算值作为方法的返回值。这也是为什么要求函数式接口只能有一个抽象方法的原因。 函数式接口中抽象方法的签名（signature）描述了 Lambda 表达式的签名，因为 Lambda 表达式并没有名字，所以这里的签名只关注三个方面：方法参数 、返回值 以及 异常声明。我们将抽象方法所描述的 Lambda 形式称为函数描述符（function descriptor）。在 Calculator 类中，cal 方法对应的函数描述符为 (int, int) -> int，即接受两个 int 类型作为参数，表达式的计算值为 int 类型。所以下面的 Lambda 表达式都是合法的： (int a, int b) -> a (int a, int b) -> a + b (int a, int b) -> 0 如果 Lambda 表达式抛出一个可检查异常，那么对应的抽象方法所声明的 throws 语句也要与之匹配。看下面的一个例子： @FunctionalInterface interface ThrowExceptionInterface { void run(int a, int b); } public class LambdaTest { public void throwException() { // 这里编译时会报 Unhandled Exception：java.io.Exception ThrowExceptionInterface t = (int a, int b) -> { throw new IOException(); }; } } 其实也很好理解，Lambda body 中的内容会作为抽象方法的具体实现，在方法中抛出了异常但是方法声明中却没有相关的异常声明，编译器肯定要报错的。 另外还有一个特殊的 void 兼容规则。如果抽象方法的返回值为 void，即对应的函数描述符为 (T) -> void，那么对于 body 为 语句表达式（statement expression） 的 Lambda 表达式，只要求参数列表匹配即可。看下面的例子： @FunctionalInterface interface VoidInterface { void run(int a); } public class LambdaTest { public static void voidTest() { List list = new ArrayList<>(); // 这里 a++ 返回一个 int，但是和 void 兼容 VoidInterface v = (int a) -> a++; // 下面的代码会报错，因为 a-1 不是一个语句表达式 v = (int a) -> a-1; } } 这里说一下语句表达式: The term “statement expression” or “expression statement” refers to expressions that are also allowed to be used as a statement. 语法表达式有下面四类： Assignment expressions Any use of ++ or -- Method invocations Object creation expressions 类型检查 Lambda 表达式本身并不包含它是实现哪个函数式接口的信息，编译器会根据 Lambda 表达式所处的上下文（context）环境来推断 Lambda 表达式的目标类型（target type），例如对于下面的代码： Calculator c = (int a, int b) -> a + b; Lambda 表达式会赋值给 Calculator 对象，那么该 Lambda 表达式对应的目标类型就是 Calculator 接口，该接口中的 cal 方法对应的函数描述符为 (int, int) -> int，这个和 (int a, int b) -> a + b 可以匹配，这样就完成了类型检查。下图是一个完整的例子： 类型推断 在上面我们提到编译器会根据上下文环境推断出与 Lambda 表达式对应的函数式接口，这意味着编译器同样可以根据接口中抽象方法的函数函数描述符推断出 Lambda 表达式的签名，这样编译器就可以知道 Lambda 表达式的参数类型，这样就可以省略 Lambda 表达式中的参数类型， Calculator c = (a, b) -> a + b; // 当只有一个参数时，可以省略掉 () VoidInterface v = a -> a++; Java 8 中的函数式接口 在 Java 8 中定义了一些函数式接口，位于 java.util.function 包下，下面是这些接口的总览： +--- BiConsumer.java +--- BiFunction.java +--- BinaryOperator.java +--- BiPredicate.java +--- BooleanSupplier.java +--- Consumer.java +--- DoubleBinaryOperator.java +--- DoubleConsumer.java +--- DoubleFunction.java +--- DoublePredicate.java +--- DoubleSupplier.java +--- DoubleToIntFunction.java +--- DoubleToLongFunction.java +--- DoubleUnaryOperator.java +--- Function.java +--- IntBinaryOperator.java +--- IntConsumer.java +--- IntFunction.java +--- IntPredicate.java +--- IntSupplier.java +--- IntToDoubleFunction.java +--- IntToLongFunction.java +--- IntUnaryOperator.java +--- LongBinaryOperator.java +--- LongConsumer.java +--- LongFunction.java +--- LongPredicate.java +--- LongSupplier.java +--- LongToDoubleFunction.java +--- LongToIntFunction.java +--- LongUnaryOperator.java +--- ObjDoubleConsumer.java +--- ObjIntConsumer.java +--- ObjLongConsumer.java +--- Predicate.java +--- Supplier.java +--- ToDoubleBiFunction.java +--- ToDoubleFunction.java +--- ToIntBiFunction.java +--- ToIntFunction.java +--- ToLongBiFunction.java +--- ToLongFunction.java +--- UnaryOperator.java Predicate 用来测试对象是否满足某种条件。该接口定义了一个 test 方法，接受一个泛型对象（T），并返回测试结果（boolean），函数描述符为 T -> boolean。下面是一个使用示例： public boolean judge(T t, Predicate p) { return p.test(t); } public void testPredicate() { String text = \"111\"; System.out.println(judge(text, s -> s != null)); } 下面是 Predicate 接口的实现： /** * Represents a predicate (boolean-valued function) of one argument. */ @FunctionalInterface public interface Predicate { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return true if the input argument matches the predicate, * otherwise false */ boolean test(T t); /** * Returns a composed predicate that represents a short-circuiting logical * AND of this predicate and another. When evaluating the composed * predicate, if this predicate is false, then the other * predicate is not evaluated. */ default Predicate and(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) && other.test(t); } /** * Returns a predicate that represents the logical negation of this * predicate. */ default Predicate negate() { return (t) -> !test(t); } /** * Returns a composed predicate that represents a short-circuiting logical * OR of this predicate and another. When evaluating the composed * predicate, if this predicate is true, then the other * predicate is not evaluated. */ default Predicate or(Predicate other) { Objects.requireNonNull(other); return (t) -> test(t) || other.test(t); } /** * Returns a predicate that tests if two arguments are equal according * to {@link Objects#equals(Object, Object)}. */ static Predicate isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -> targetRef.equals(object); } } 我们看到在 Predicate 类中，除了 test 方法，还定义了三个 default 方法，and, or 和 negate，它们分别对应逻辑运算中的与（&&）、或（||）、非（!）操作。通过这三个方法，我们可以构造更复杂的 predicate 表达式： public void testPredicate() { String text = \"111\"; Predicate a = s - > s != null; Predicate b = s - > s.length() > 3; System.out.println(judge(text, a.and(b))); System.out.println(judge(text, a.negate())); System.out.println(judge(text, a.or(b))); } 对应的输出结果为： false false true 另外 and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此 a.or(b).and(c) 可以看作 (a || b) && c。 BiPredicate BiPredicate 针对两个参数对象（T, U）进行测试，函数描述符为 (T, U) -> boolean。下面是该接口的定义： /** * Represents a predicate (boolean-valued function) of two arguments. This is * the two-arity specialization of {@link Predicate}. */ @FunctionalInterface public interface BiPredicate { boolean test(T t, U u); default BiPredicate and(BiPredicate other) { Objects.requireNonNull(other); return (T t, U u) -> test(t, u) && other.test(t, u); } default BiPredicate negate() { return (T t, U u) -> !test(t, u); } default BiPredicate or(BiPredicate other) { Objects.requireNonNull(other); return (T t, U u) -> test(t, u) || other.test(t, u); } } 下面是一个使用示例： public void testBiPredicate() { BiPredicate b = (x, y) -> x > 0 && y > 3; boolean r = b.test(1, 4); System.out.println(r); } Consumer Consumer（消费者），针对对象进行某种操作（消费对象）。该接口定义了一个 accept 方法，会将该方法作用于目标对象，函数描述符为 T -> void。下面是使用示例： public void consume(T t, Consumer c) { c.accept(t); } @Test public void testConsume() { String text = \"1234\"; consume(text, s -> System.out.println(s.substring(2))); } 下面是 Consumer 类的代码 /** * Represents an operation that accepts a single input argument and returns no * result. Unlike most other functional interfaces, Consumer is expected * to operate via side-effects. */ @FunctionalInterface public interface Consumer { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t); /** * Returns a composed Consumer that performs, in sequence, this * operation followed by the after operation. If performing either * operation throws an exception, it is relayed to the caller of the * composed operation. If performing this operation throws an exception, * the after operation will not be performed. */ default Consumer andThen(Consumer after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } Consumer 中定义了一个 andThen 的 default 方法，通过该方法我们可以对目标对象进行链式（chain）处理，下面是一个示例： public void testConsume() { StringBuilder builder = new StringBuilder(); Consumer a = s -> s.append(\"abcd\"); Consumer b = s -> s.reverse(); Consumer c = s -> s.append(\"1234\"); consume(builder, a.andThen(b).andThen(c)); System.out.println(builder.toString()); } 输出结果为： dcba1234 BiConsumer BiConsumer 针对两个对象（T, U）进行操作，对应的函数描述符为 (T, U) -> void。下面是该接口的定义： /** * Represents an operation that accepts two input arguments and returns no * result. This is the two-arity specialization of Consumer. * Unlike most other functional interfaces, BiConsumer is expected * to operate via side-effects. */ @FunctionalInterface public interface BiConsumer { void accept(T t, U u); default BiConsumer andThen(BiConsumer after) { Objects.requireNonNull(after); return (l, r) -> { accept(l, r); after.accept(l, r); }; } } 下面是一个例子： public void testBiConsumer() { BiConsumer b = (x, y) -> System.out.println(x + y); b.accept(\"111\", \"222\"); } Supplier Supplier（供应商），返回一个泛型对象（生产对象）。该接口中定义了一个 get 方法，没有方法参数，返回值是一个泛型对象，函数描述符为 () -> T。下面是一个使用示例 public T supplier(Supplier s) { return s.get(); } public void testSupplier() { String text = supplier(() -> \"1111\"); System.out.println(text); } 下面是 Supplier 接口的定义： /** * Represents a supplier of results. */ @FunctionalInterface public interface Supplier { /** * Gets a result. */ T get(); } Function Function 接口就相当于 y=f(x) 中的函数 f，接收一个 x（argument）返回计算值 y（result）。该接口定义了一个 apply 方法，接收一个 T 类型的对象，返回一个 R 类型的结果，函数描述符为 T -> R。下面是一个使用示例： public R func(T t, Function f) { return f.apply(t); } public void testFunction() { String text = \"1234\"; int i = func(text, t -> Integer.parseInt(t)); // 输出 1235 System.out.println(i + 1); } 下面是 Function 接口的定义： /** * Represents a function that accepts one argument and produces a result. */ @FunctionalInterface public interface Function { /** * Applies this function to the given argument. */ R apply(T t); /** * Returns a composed function that first applies the before * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default Function compose(Function before) { Objects.requireNonNull(before); return (V v) -> apply(before.apply(v)); } /** * Returns a composed function that first applies this function to * its input, and then applies the after function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default Function andThen(Function after) { Objects.requireNonNull(after); return (T t) -> after.apply(apply(t)); } /** * Returns a function that always returns its input argument. */ static Function identity() { return t -> t; } } 在 Function 接口中定义了两个 default 方法：compose 和 andThen 可以进行链式的调用，假设有两个函数 f(x) 和 g(x): f.compose(g) => f(g(x)) f.andThen(g) => g(f(x)) 下图是一个详细的解释 下面是一个使用示例： public void testFunction() { Function f = x -> x + 1; Function g = x -> x * 2; int i = func(1, f.andThen(g)); // 输出 4 System.out.println(i); i = func(1, f.compose(g)); // 输出 3 System.out.println(i); } UnaryOperator UnaryOperator 是一种特殊的 Function，表示操作数和返回值是同一种类型，函数描述符为 T -> T。下面是该接口的定义： /** * Represents an operation on a single operand that produces a result of the * same type as its operand. This is a specialization of {@code Function} for * the case where the operand and result are of the same type. */ @FunctionalInterface public interface UnaryOperator extends Function { /** * Returns a unary operator that always returns its input argument. */ static UnaryOperator identity() { return t -> t; } } 下面是一个使用示例： public void testUnaryOperator() { UnaryOperator u = x -> x + 1; System.out.println(u.apply(1)); } BiFunction BiFunction 接收两个参数（T, U），返回一个结果（R），类似于 z=f(x, y)，对应的函数描述符为 (T, U) -> R。下面是该接口的具体实现： /** * Represents a function that accepts two arguments and produces a result. * This is the two-arity specialization of Function. */ @FunctionalInterface public interface BiFunction { /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u); /** * Returns a composed function that first applies this function to * its input, and then applies the {@code after} function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. */ default BiFunction andThen(Function after) { Objects.requireNonNull(after); return (T t, U u) -> after.apply(apply(t, u)); } } 下面是一个使用示例： public void testBiFunction() { BiFunction b = (i, d) -> String.valueOf(i + d); String r = b.apply(1, 2.5); System.out.println(r); } BinaryOperator BinaryOperator 是一种特殊的 BiFunction，表示接收的参数和返回的结果都是同一种类型 T，函数描述符为 (T, T) -> T。下面是该接口的定义： /** * Represents an operation upon two operands of the same type, producing a result * of the same type as the operands. This is a specialization of * BiFunction for the case where the operands and the result are all of * the same type. */ @FunctionalInterface public interface BinaryOperator extends BiFunction { /** * Returns a BinaryOperator which returns the lesser of two elements * according to the specified Comparator. */ public static BinaryOperator minBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) BinaryOperator maxBy(Comparator comparator) { Objects.requireNonNull(comparator); return (a, b) -> comparator.compare(a, b) >= 0 ? a : b; } } 下面是一个使用示例: public void testBinaryOperator() { BinaryOperator b = (x, y) -> x + y; int z = b.apply(1, 3); System.out.println(z); BinaryOperator min = BinaryOperator.minBy((x, y) -> x - y); // 输出 1 z = min.apply(1, 3); System.out.println(z); // 输出 3 BinaryOperator max = BinaryOperator.maxBy((x, y) -> x - y); z = max.apply(1, 3); System.out.println(z); } Primitive specializations 在上面提到的接口中，都是接受泛型参数，我们知道泛型参数只能是引用类型，也就是说对于 int 这样的基本类型，我们要首先装箱（boxing）成 Integer 类型，在使用的时候再拆箱（unboxing）成 int。虽然 Java 提供了自动装箱机制，但是在性能方面是要付出代价的。所以对于上述的函数式接口，Java 8 提供了针对基本类型的版本，以此来避免输入输出是基本类型时的自动装箱操作。以 Predicate 为例，假设我们要检测一个 int 是否满足某个条件，我们可以使用 IntPredicate ： public void testIntPredicate() { IntPredicate ip = x -> x > 3; boolean r = ip.test(4); System.out.println(r); } 下面是 IntPredicate 的定义，我们可以看到它将泛型 T 改为了基本类型 int。 /** * Represents a predicate (boolean-valued function) of one {@code int}-valued * argument. This is the {@code int}-consuming primitive type specialization of * {@link Predicate}. */ @FunctionalInterface public interface IntPredicate { boolean test(int value); default IntPredicate and(IntPredicate other) { Objects.requireNonNull(other); return (value) -> test(value) && other.test(value); } default IntPredicate negate() { return (value) -> !test(value); } default IntPredicate or(IntPredicate other) { Objects.requireNonNull(other); return (value) -> test(value) || other.test(value); } } 下表列出了 Java 8 中的函数式接口以及其对应的基本类型版本： 函数式接口 函数描述符 基本类型版本 Predicate T -> boolean IntPredicate, LongPredicate, DoublePredicate BiPredicate (L, R) -> boolean Consumer T -> void IntConsumer, LongConsumer, DoubleConsumer BiConsumer (T, U) -> void ObjIntConsumer, ObjLongConsumer, ObjDoubleConsumer Supplier () -> T BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier Function T -> R IntFunction, IntToDoubleFunction, IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, DoubleFunction, ToIntFunction, ToDoubleFunction, ToLongFunction UnaryOperator T -> T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BiFunction (T, U) -> R ToIntBiFunction, ToLongBiFunction, ToDoubleBiFunction BinaryOperator (T, T) -> T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator "},"java8/方法引用.html":{"url":"java8/方法引用.html","title":"方法引用","keywords":"","body":"方法引用 HelloWorld 方法引用形式 实例方法引用 构造方法引用 HelloWorld 方法引用实际上就是根据已有的方法实现来创建 Lambda 表达式。方法引用通过 :: 来使用，下面是一个基本的示例： import org.junit.Test; import java.util.function.IntUnaryOperator; public class HelloWorld { public void increase(int i, IntUnaryOperator o) { System.out.println(o.applyAsInt(i)); } @Test public void testMethod() { IntUnaryOperator operator = Adder::addOne; System.out.println(operator.applyAsInt(1)); } } class Adder { public static int addOne(int i) { return i + 1; } } 方法引用形式 方法引用主要有下面四种形式： 类名::静态方法，例如 Integer::parseInt。 类名::实例方法，例如 String::length，这里有个限制，就是方法接受的第一个参数类型必须是该实例类。 对象::实例方法，例如有一个 String 类型 text，那么就可以写作 text::length。 类名::new，构造方法引用 其实上面的四种形式也可以归纳为三种，静态方法引用，实例方法引用以及构造方法引用，静态方法的方法引用很简单，就是 类名::方法名，只需要保证参数列表和返回值一致即可。下面主要来说下实例方法和构造方法引用。 实例方法引用 实例方法引用有两种形式： 类名::实例方法 对象::实例方法 这两种形式可能有些迷惑，我们首先看下下面的代码： import org.junit.Test; import java.util.function.Function; class Person { private String name; public Person() { } public Person(String name) { this.name = name; } public String getName() { return name; } public String mergeName(Person p) { return name + \" \" + p.name; } } public class InstanceMethod { @Test public void run() { Person a = new Person(\"aa\"); Person b = new Person(\"bb\"); // 第一种形式 Function f = Person::getName; String r = f.apply(b); System.out.println(r); // 第二种形式 Function f2 = a::mergeName; r = f2.apply(b); System.out.println(r); } } 下面是两种方式对应的 Lambda 形式 Person::getName --> (Person p) -> p.getName(); a::mergeName --> (Person p) -> a.mergeName(p); 从上面我们可以看出，当使用 类名::实例方法 这种形式时，是由 Lambda 接收的第一个参数来调用这个实例方法的，如果 Lambda 接受多个参数，比如接收 3 个参数，那么第 2 和 第 3 个参数会作为实例方法的参数，这也是为什么要求 Lambda 表达式接收的第一个参数类型必须是该实例类。 构造方法引用 可以使用 类名::new 来构建构造方法引用。下面是一个示例： public class ConstructorMethod { @Test public void run() { // 相当于 Supplier t = () -> new Person(); Supplier s = Person::new; Person p = s.get(); System.out.println(p.getName()); // 相当于 Function t = (name) -> new Person(name); Function f = Person::new; p = f.apply(\"1234\"); System.out.println(p.getName()); } } "},"java8/stream.html":{"url":"java8/stream.html","title":"Stream","keywords":"","body":"Stream 定义 使用流 创建流 只能遍历一次 流操作 flatMap reduce 操作状态 收集数据 集合 规约和汇总 定义 流 （Stream）允许我们以声明性方式（declarative way）处理数据集合。流的简短定义为：a sequence of elements from a source that supports data processing operations（从支持数据处理操作的源生成的元素序列），我们来详细看下这个定义： Sequence of elements（元素序列）- 流提供了类似于集合（Collection）的接口，额可以操作特定元素类型的一组有序值。不过两者的关注点不同，集合主要关注数据（data），流主要关注计算（computation）。 Source（源）- 流需要一个提供数据的源，这个源可以是 collections，arrays 或者 I/O resources. 从有序集合生成的流会保留原有的数据。 Data processing operations（数据处理操作）- 流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，例如 filter、map、reduce、find、match、sort 等。流操作可以顺序执行，也可以并行执行。 另外，流操作还有两个重要的特点： Pipelining（流水线） - 很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线，流水线的操作支持延迟（laziness）和短路（short-circuiting）。流水线的操作可以看作对数据源进行数据库式的查询。 Internal iteration（内部迭代）- 和集合使用显式的的迭代器不同，流的迭代操作是在背后执行的，对于用户来说是透明的。 下面是一个使用示例： import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; public class HelloWorld { public static void main(String[] args) { List list = new ArrayList<>(); list.add(5); list.add(10); list.add(1); list.add(-1); list.add(1000); list.add(100); List result = list.stream() .filter(i -> i > 10) .sorted() .collect(Collectors.toList()); result.forEach(System.out::println); } } 使用流 创建流 下面是创建流的几种方式： 由值创建流 由数组 / 集合创建流 由文件生成流 由函数生成流，该操作生成的流属于无限流 Stream.iterate：接受一个初始值，每次迭代在之前迭代的结果上应用传入 lambda 表达式public static Stream iterate(final T seed, final UnaryOperator f)` Stream.generate：根据传入的 s 生成结果值public static Stream generate(Supplier s) 下面是一个使用示例： import org.junit.Test; import java.io.IOException; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Paths; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.IntStream; import java.util.stream.Stream; public class CreateStream { @Test public void fromValue() { Stream stream = Stream.of(\"aaa\", \"bbb\", \"ccc\", \"ddd\"); stream.map(String::toUpperCase).forEach(System.out::println); } @Test public void fromCollection() { List list = new ArrayList<>(); list.add(\"111\"); list.add(\"222\"); list.add(\"333\"); Integer sum = list.stream() .map(Integer::parseInt) .reduce(Integer::sum).get(); System.out.println(sum); } @Test public void fromArray() { int[] arr = new int[]{1, 3, 5, 7}; IntStream stream = Arrays.stream(arr); int sum = stream.sum(); System.out.println(sum); String[] strArr = new String[]{\"aaa\", \"bbb\", \"ccc\", \"ddd\"}; Stream stringStream = Arrays.stream(strArr); stringStream.map(String::toUpperCase).forEach(System.out::println); } @Test public void fromFile() { long uniqueWords = 0; try (Stream lines = Files.lines(Paths.get(\"data.txt\"), Charset.defaultCharset())) { uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(\" \"))).distinct().count(); System.out.println(uniqueWords); } catch (IOException e) { e.printStackTrace(); } } /** * 由函数生成流 */ @Test public void fromIterate() { Stream.iterate(0, n -> n + 2) .limit(10) .forEach(System.out::println); } @Test public void fromGenerate() { Stream.generate(Math::random) .limit(5) .forEach(System.out::println); } } 只能遍历一次 流只能被遍历一次，当遍历完之后，我们就说这个流被消费掉了。下面是一个示例： @Test public void streamTest() { Stream stream = Stream.of(1, 3, 5); stream.filter(i -> i > 1).forEach(System.out::println); // 下面的代码会报错，因为流已经关闭了 stream.filter(i -> i > 1).forEach(System.out::println); } 流操作 流操作可以分为两大类：中间操作（intermediate operations）和终端操作（terminal operation）。中间操作是延迟（lazy）计算的，在触发一个终端操作之前，中间操作不会进行任何处理。下面是一个示意图： 中间操作一般可以合并起来，在终端操作时一次性全部处理。在使用流时一般会包含下面三个部分： 执行查询的 数据源（data source） 组成流水线的 中间操作链（chain of intermediate operations） 执行流水线并且生成最终结果的 终端操作（terminal operation） 下面是常用的流操作列表 操作 操作类型 返回类型 参数类型 函数描述符 filter 中间 Stream Predicate T -> boolean distinct 中间 有状态-无界 Stream skip 中间 有状态-有界 Stream long limit 中间有状态-有界 Stream map 中间 Stream Function T -> R flatMap 中间 Stream Function> T -> Stream sorted 中间 Stream Comparator (T, T) -> int anyMatch 终端 boolean Predicate T -> boolean noneMatch 终端 boolean Predicate T -> boolean allMatch 终端 boolean Predicate T -> boolean findAny 终端 Optional findFirst 终端 Optional forEach 终端 void Comsumer T -> void collect 终端 R Collector reduce 终端 有状态-有界 Optional BinaryOperator (T, T) -> T count 终端 long 下面是部分流操作的示例 public void streamOperations() { Integer[] arr = new Integer[]{1, 2, 6, 1, 3, 8, 10}; // filter: 根据条件过滤 // forEach: 遍历流中的元素 Arrays.stream(arr).filter(i -> i > 1).forEach(System.out::println); System.out.println(); // distinct: 去重 Arrays.stream(arr).distinct().forEach(System.out::println); System.out.println(); // sorted: 排序 Arrays.stream(arr).sorted().forEach(System.out::println); System.out.println(); // skip: 跳过前面的元素 Arrays.stream(arr).skip(2).forEach(System.out::println); System.out.println(); // limit: 限制获取的元素数量 Arrays.stream(arr).limit(2).forEach(System.out::println); System.out.println(); // map: 元素映射， T -> R Arrays.stream(arr).map(String::valueOf).forEach(v -> System.out.println(v.length())); System.out.println(); // anyMatch:任一元素匹配 boolean result = Arrays.stream(arr).anyMatch(i -> i > 5); System.out.println(result); // noneMatch: 无元素匹配 result = Arrays.stream(arr).noneMatch(i -> i > 5); System.out.println(result); // allMatch: 全部元素匹配 result = Arrays.stream(arr).allMatch(i -> i > 5); System.out.println(result); // findAny: 返回流中任一元素 Optional optional = Arrays.stream(arr).findAny(); System.out.println(optional.get()); // findFirst: 返回流中的第一个元素 optional = Arrays.stream(arr).findFirst(); System.out.println(optional.get()); // count: 统计流中元素个数 long count = Arrays.stream(arr).count(); System.out.println(count); } flatMap map 主要的的功能是用来做映射，即将输入的 T 类型转为 R 类型。map 主要针对一维的数据结构（例如一维数组），当数据结构为二维的时候（比如二维数组或者集合数组），map 也会将其作为一维数据结构处理，比如下面的二维数组，map 会将内层的一维数组看作是一个整体。 [ [1, 3, 4], [1, 2, 3], [2, 2, 6] ] 但是我们可能希望对二维数组中的全部数据进行处理，那么一个简单的办法就是将二维数组展平为一维数组，即下面的形式： [1, 3, 4, 1, 2, 3, 2, 2, 6] 这样在 map 时就是针对的数组中的全部数据。Java 8 为我们提供了 flatMap 来完成上面的工作。我们首先看下 flatMap 的定义： /** * Returns a stream consisting of the results of replacing each element of * this stream with the contents of a mapped stream produced by applying * the provided mapping function to each element. Each mapped stream is * {@link java.util.stream.BaseStream#close() closed} after its contents * have been placed into this stream. (If a mapped stream is {@code null} * an empty stream is used, instead.) */ Stream flatMap(Function> mapper); 我们看到 flatMap 接受的参数为 Function，这个 Function 的功能是将 T 转换为 Stream (super 和 extends 一会再说)。flatMap 的功能就是通过转换函数 mapper，将之前流中的每个元素转换成一个流，然后把所有的流连接成一个流。下面是一个示例： public void useFlatMap() { Integer[][] array = new Integer[][]{ new Integer[]{1, 3, 4}, new Integer[]{1, 2, 3}, new Integer[]{2, 2, 6} }; List results = Arrays.stream(array).distinct().collect(Collectors.toList()); results.forEach(arr -> System.out.println(Arrays.toString(arr))); List results2 = Arrays.stream(array).flatMap(Arrays::stream).distinct().collect(Collectors.toList()); results2.forEach(System.out::println); } 在上面的例子中，通过 Arrays.stream 可以将二维数组 array 转换为一个流 s，其中流中的元素数据类型为 Integer[]，当调用 flatMap 之后， 流 s 中的每个元素都通过 Arrays.stream 方法转换为一个流，记为 ss1, ss2, ss3，流 ss1, ss2, ss3 中数据类型为 Integer，然后 flatMap 将 ss1, ss2 和 ss3 合并成一个新的流 s2，流 s2 中就包含了 array 的所有元素（相当于把 array 展平为了一维数组）。 下面是一个示意图： 我们再来看下泛型中的 super 和 extends， // 这里只看泛型，所以省略 ? extends Stream Function mapper ? super T 表示接受的类型是 T 或者 T 的父类，? extends R 表示接受的类型为 R 或者 R 的子类。假设我们有下面的继承关系： class Animal { public void run() { System.out.println(\"animal run\"); } } class Cat extends Animal { public void jump() { System.out.println(\"cat jump\"); } } class WhiteCat extends Animal { public void printColor() { System.out.println(\"white\"); } } 我们先来看 super，假设 Stream 中元素类型都是 Cat 类型，即 mapper 的输入类型是 Cat，假设我们不加 ? super T 限制，将参数的定义改为 Function mapper, 那么将下面的 Function m 传入 flatMap 时，编译时不会报错，但是执行的时候会报错，因为 Function m 接受的类型是 WhiteCat，但是我们给 m 传的 Cat 类型，Cat 类中根本没有 printColor 函数。 // 这里忽略输出类型 Function m = (c, ?) -> c.printColor(); 如果我们将下面的 Function m2 传入 flatMap，那么编译和运行时都不会报错，因为 Cat 是 Animal 的子类，会继承 Animal 的 run 方法。 Function m2 = (a, ?) -> a.run(); 由此我们可以知道当 Stream 中类型为 Cat 时，我们传入的 Function 接受类型可以是 Cat 或者 Cat 的父类，但不能是 Cat 的子类，所以在参数定义时加上 ? super T，以便在编译阶段就可以发现错误。 下面我们在看下 extends，mapper 的用法大致如下面的代码所示，流 s 中的数据类型要为 R 或者 R 的子类，所以在参数定义中使用 ? extends R 表明 mapper 返回流中的数据必须为 R 或者 R 的子类。 Stream s = mapper(t); 上面的用法就是我们所说的 PECS （Producer Extends Consumer Super）元素： 如果要从对象或者集合中获取 T 类型的数据，并且不需要写入，可以使用 ? extends 通配符 如果要向对象或者集合中写入 T 类型的数据，并且不需要读取，可以使用 ? super 通配符 如果既要存又要取，那么就不要用任何通配符。 在上面的例子中，我们要向 mapper 对象中传入 T 类型，获取 Stream 类型，所以统配符使用 Function> mapper reduce reduce 操作将流中所有的值规约成一个值（比如求和、求最大最小值），用函数式编程语言的术语来说，这也称为折叠（fold）。下面是一个使用示例： public void useReduce() { Integer[] numbers = new Integer[] {1, 2, 4, 6, 10}; // 求和 int sum = Arrays.stream(numbers).reduce(0, Integer::sum); System.out.println(sum); // 求最大值 Optional o = Arrays.stream(numbers).reduce(Integer::max); System.out.println(o.get()); // 求最小值 o = Arrays.stream(numbers).reduce(Integer::min); System.out.println(o.get()); } reduce 将外部迭代的过程抽象到了内部迭代中，有利于并行化的实现。 操作状态 对于 map 或者 filter 这样的流操作来说，它们操作的对象是流中的单个元素，在执行操作的时候，各个元素之间不会相互影响，这些操作一般都是无状态的（stateless），这里假设用户提供的 Lambda 表达式中没有内部状态。无状态的操作更利于并行。 诸如 reduce、sum、max 等操作，需要内部状态来累积结果，但是这种情况下内部状态很小，在 reduce 中就是一个int 或者 double。不论流中有多少元素要处理，内部状态都是有界的。 对于 sort 或者 distinct 操作来说，操作时都需要知道之前操作的结果，这种操作的存储要求是无界的，我们通常把这些操作称为有状态操作（stateful） 收集数据 使用 Stream 的 collect 方法可以收集流中的数据，collect 方法接收一个 Collector 类型的参数，用于指定收集的逻辑，下面是 collect 方法的定义： R collect(Collector collector); Java 8 中 Collectors 提供了一些预定义的收集器，主要包含下面四个功能： 收集为集合 规约和汇总：Reducing and summarizing stream elements to a single value 分组：Grouping elements 分区：Partitioning elements 集合 流中的数据可以被收集成 List、Set 或者 Map 的集合类，下面是相关函数的定义： /** * Returns a {@code Collector} that accumulates the input elements into a * new {@code Collection}, in encounter order. The {@code Collection} is * created by the provided factory. * @param collectionFactory a {@code Supplier} which returns a new, empty */ public static > Collector toCollection(Supplier collectionFactory) /** * Returns a {@code Collector} that accumulates the input elements into a * new {@code List}. There are no guarantees on the type, mutability, * serializability, or thread-safety of the {@code List} returned; if more * control over the returned {@code List} is required, use {@link #toCollection(Supplier)}. */ public static Collector> toList() /** * Returns a {@code Collector} that accumulates the input elements into a * new {@code Set}. There are no guarantees on the type, mutability, * serializability, or thread-safety of the {@code Set} returned; if more * control over the returned {@code Set} is required, use * {@link #toCollection(Supplier)}. */ public static Collector> toSet() /** * Returns a {@code Collector} that accumulates elements into a * {@code Map} whose keys and values are the result of applying the provided * mapping functions to the input elements. * * If the mapped * keys contains duplicates (according to {@link Object#equals(Object)}), * the value mapping function is applied to each equal element, and the * results are merged using the provided merging function. The {@code Map} * is created by a provided supplier function. * * @implNote * The returned {@code Collector} is not concurrent. For parallel stream * pipelines, the {@code combiner} function operates by merging the keys * from one map into another, which can be an expensive operation. If it is * not required that results are merged into the {@code Map} in encounter * order, using {@link #toConcurrentMap(Function, Function, BinaryOperator, Supplier)} * may offer better parallel performance. * * @param keyMapper a mapping function to produce keys * @param valueMapper a mapping function to produce values * @param mergeFunction a merge function, used to resolve collisions between * values associated with the same key, as supplied * to {@link Map#merge(Object, Object, BiFunction)} * @param mapSupplier a function which returns a new, empty {@code Map} into * which the results will be inserted */ public static > Collector toMap(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction, Supplier mapSupplier) /** * Returns a {@code Collector} that accumulates elements into a * {@code Map} whose keys and values are the result of applying the provided * mapping functions to the input elements. * * If the mapped * keys contains duplicates (according to {@link Object#equals(Object)}), * the value mapping function is applied to each equal element, and the * results are merged using the provided merging function. * * @param keyMapper a mapping function to produce keys * @param valueMapper a mapping function to produce values * @param mergeFunction a merge function, used to resolve collisions between * values associated with the same key, as supplied * to {@link Map#merge(Object, Object, BiFunction)} */ public static Collector> toMap(Function keyMapper, Function valueMapper, BinaryOperator mergeFunction) { return toMap(keyMapper, valueMapper, mergeFunction, HashMap::new); } /** * Returns a {@code Collector} that accumulates elements into a * {@code Map} whose keys and values are the result of applying the provided * mapping functions to the input elements. * * If the mapped keys contains duplicates (according to * {@link Object#equals(Object)}), an {@code IllegalStateException} is * thrown when the collection operation is performed. If the mapped keys * may have duplicates, use {@link #toMap(Function, Function, BinaryOperator)} * instead. * * @param keyMapper a mapping function to produce keys * @param valueMapper a mapping function to produce values */ public static Collector> toMap(Function keyMapper, Function valueMapper) { return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new); } 下面是使用示例： public void testCollection() { Integer[] array = new Integer[]{1, 3, 1, 4, 6, 4, 7}; // 收集为 List（ArrayList），输出结果为：[1, 3, 1, 4, 6, 4, 7] List list = Arrays.stream(array).collect(Collectors.toList()); System.out.println(list); // 收集为 Set（HashSet），输出结果为 [1, 3, 4, 6, 7] Set set = Arrays.stream(array).collect(Collectors.toSet()); System.out.println(set); /* * 在前面的示例中，toList 只能生成 ArrayList, toSet 只能生成 HashSet * 所以又额外提供了一个 toCollection 允许用户传入一个 Supplier 对象，用于自定义集合类的类型 */ Collection c = Arrays.stream(array).collect(Collectors.toCollection(LinkedList::new)); System.out.println(c); /* * 收集为 map（HashMap），第一个参数为 key 的映射，第二个参数为 value 的映射。 * 这里需要注意的是 key 值不能有重复。输出结果为：{1=1, 3=1, 4=1, 6=1, 7=1} */ array = new Integer[]{1, 3, 6, 4, 7}; Map map = Arrays.stream(array).collect(Collectors.toMap(i -> i, i -> 1)); System.out.println(map); /* * 第三个参数为冲突合并函数，当 key 值冲突时，会调用该函数合并 value 值 * 输出结果为：{1=2, 3=3, 4=8, 6=6, 7=7} */ array = new Integer[]{1, 3, 1, 4, 6, 4, 7}; map = Arrays.stream(array).collect(Collectors.toMap(i -> i, i -> i, (a, b) -> a + b)); System.out.println(map); /* * 第四个参数用来自定义 Map 的类型 */ map = Arrays.stream(array).collect(Collectors.toMap(i -> i, i -> i, (a, b) -> a + b, TreeMap::new)); System.out.println(map); } Collectors 也提供了 toConcurrentMap 的方法，这里不再赘述。 规约和汇总 下面是使用预定义收集器进行规约和汇总的一些示例： public void summarize() { Integer[] array = new Integer[]{1, 3, 6, 8, 3, 2}; // 求和 long count = Arrays.stream(array).collect(Collectors.counting()); System.out.println(count); // 求最大值 Optional max = Arrays.stream(array).collect(Collectors.maxBy(Comparator.comparing(i -> i))); System.out.println(max.get()); // 求最小值 Optional min = Arrays.stream(array).collect(Collectors.minBy(Comparator.comparing(i -> i))); System.out.println(min.get()); // 求和， Collectors.summingLong 和 Collectors.summingDouble 用于 long 和 double 类型的求和 int total = Arrays.stream(array).collect(Collectors.summingInt(i -> i)); System.out.println(total); // 求平均数， Collectors.averagingLong 和 Collectors.averagingDouble 用于求 long 和 double 类型的平均值 // 需要注意的是返回值均为 double double average = Arrays.stream(array).collect(Collectors.averagingInt(i -> i)); System.out.println(average); // 字符串连接 String text = Arrays.stream(array).map(String::valueOf).collect(Collectors.joining(\", \")); System.out.println(text); /** * 获得多个统计信息，包括 sum, average, min, max 和 count * * Collectors.summarizingLong 和 Collectors.summarizingDouble 用于统计 long 和 double 类型 */ IntSummaryStatistics statistics = Arrays.stream(array).collect(Collectors.summarizingInt(i -> i)); System.out.println(statistics); } Collectors 中提供了一个更为通用的 reducing 方法来实现规约功能，上面的方法可以看作是 reducing 方法的特例，我们来看下 reducing 方法的定义： /** * Returns a {@code Collector} which performs a reduction of its * input elements under a specified {@code BinaryOperator}. The result * is described as an {@code Optional}. * * @param op a {@code BinaryOperator} used to reduce the input elements */ public static Collector> reducing(BinaryOperator op) /** * Returns a {@code Collector} which performs a reduction of its * input elements under a specified {@code BinaryOperator} using the * provided identity. * * @param identity the identity value for the reduction (also, the value * that is returned when there are no input elements) * @param op a {@code BinaryOperator} used to reduce the input elements */ public static Collector reducing(T identity, BinaryOperator op) /** * Returns a {@code Collector} which performs a reduction of its * input elements under a specified mapping function and * {@code BinaryOperator}. This is a generalization of * {@link #reducing(Object, BinaryOperator)} which allows a transformation * of the elements before reduction. * * @apiNote * The {@code reducing()} collectors are most useful when used in a * multi-level reduction, downstream of {@code groupingBy} or * {@code partitioningBy}. To perform a simple map-reduce on a stream, * use {@link Stream#map(Function)} and {@link Stream#reduce(Object, BinaryOperator)} * instead. * * @param identity the identity value for the reduction (also, the value * that is returned when there are no input elements) * @param mapper a mapping function to apply to each input value * @param op a {@code BinaryOperator} used to reduce the mapped values */ public static Collector reducing(U identity, Function mapper, BinaryOperator op) 我们来看下最后一个方法中的参数 U indentity: 规约操作的初始值，当流中没有元素时会返回该值。 Function<> mapper: 映射函数 BinaryOperator op: 进行规约时使用的函数 public void reducing() { Integer[] array = new Integer[]{1, 3, 6, 8, 3, 2}; int total = Arrays.stream(array).collect(Collectors.reducing(0, Integer::sum)); System.out.println(total); Optional optional = Arrays.stream(array).collect(Collectors.reducing(Integer::sum)); System.out.println(optional.get()); } "}}