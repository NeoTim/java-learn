# JVM
<!-- toc -->
## 基本分区
Java 虚拟机运行时会将数据分为下面 5 个数据区域：
* 程序计数器：线程私有，可以看作是当前线程的字节码行号计数器，该区域是 Java 虚拟机中唯一一个没有规定任何 OutOfMemoryError 的区域。
* 虚拟机栈：线程私有，生命周期和线程相同，每个方法执行时，都会创建要给栈帧，用来存放局部变量表、操作数栈、动态链接、方法出口等信息。栈中主要存放：
    - 一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄【例如：在函数中定义的一些基本类型的变量和对象的引用变量】。
    - 方法的形参 直接在栈空间分配，当方法调用完成后从栈空间回收。
* 本地方法栈：线程私有，主要为 Native 方法服务
* 堆：线程间共享，主要用来存放对象的实例。
* 方法区：线程间共享，主要用来存储以被虚拟机加载的类信息、常量、静态变量、即时编译器编译之后的代码。

## 方法区迁移
1. JDK1.2 ~ JDK6: 在 JDK1.2 ~ JDK6 的实现中，HotSpot 使用永久代实现方法区；HotSpot 使用 GC 分代实现方法区带来了很大便利；
2. JDK7: 由于 GC 分代技术的影响，使之许多优秀的内存调试工具无法在 Oracle HotSpot之上运行，必须单独处理；并且 Oracle 同时收购了 BEA 和 Sun 公司，同时拥有 JRockit 和 HotSpot，在将 JRockit 许多优秀特性移植到 HotSpot 时由于 GC 分代技术遇到了种种困难，所以从 JDK7 开始 Oracle HotSpot 开始移除永久代。JDK7中符号表被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。
3. JDK8: 在 JDK8 中，永久代已完全被元空间(Meatspace)所取代。

绝大部分 Java 程序员应该都见过 "java.lang.OutOfMemoryError: PermGen space "这个异常。这里的 PermGen space 其实指的就是方法区。不过方法区和 PermGen space 又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 PermGen space，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有 PermGen space。

Java8 之后：方法区作为概念上的区域仍然存在。原先永生代中类的元信息会被放入本地内存（元数据区，metaspace），将类的静态变量和内部字符串放入到 Java 堆中。

## 对象创建
创建 Java 对象的几种方式：
* 使用new关键字创建对象
* 使用Class类的newInstance方法(反射机制)
* 使用Constructor类的newInstance方法(反射机制)
* 使用Clone方法创建对象
* 使用(反)序列化机制创建对象

当虚拟机遇到 new 指令时，首先去检查相关的类是否被加载，如果被加载，就先去执行相应的类加载过程。然后进行对象的创建
1. 分配空间
2. 初始化父类--A类属性：这里会将属性设为默认值
3. 调用父类--A类的构造方法：在调用构造方法之前会先执行 实例变量的赋值和实例代码块中的代码
4. 初始化子类 B的属性。
5. 调用子类B的构造方法。

在类加载时会初始化静态变量，静态变量和静态代码库按照代码的先后顺序执行。

## 判断对象存活
1. 引用计数法：给对象添加一个引用计数器，每当一个地方引用它，计数器就加 1，当引用失效时，计数器就减 1。无法解决循环引用问题。
2. 可达性分析：通过一系列称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象没有任何引用链到达 GC Root 对象，则证明此对象是不可用的。

## 引用类别
* 强引用：最普遍的引用，只要强引用存在，垃圾回收器永远不会回收引用的对象
* 软引用：在内存发生溢出之前才会回收这些对象
* 弱引用：当垃圾收集器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象
* 虚引用：设置虚引用的唯一目的就是对象对收集器回收时会收到一个系统通知

## 垃圾回收算法
* 标记-清除 （Mark-Sweep）：首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
  - 不足点有两个地方：1.效率问题 2.空间问题，会产生内存碎片。
* 复制算法：将内存划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完之后，就将存活的对象复制到另外一块上，然后将本块的内存空间一次清理掉。
  - 一般将内存分为一块较大的 Eden 和 两块较小的 Survivor 空间，每次使用 Eden 和其中的一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性的复制到另外一块的 Survivor 上 。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1。
* 标记-整理（Mark-Compact）：首先标记存活对象，然后让所有的存活对象都向一端移动，然后直接清理掉边界以外的内存。

## 垃圾收集器
* Serial 收集器：新生代垃圾收集器。单线程运行，进行垃圾收集时必须暂停其他所有的工作线程。Stop the World
* ParNew 收集器：新生代垃圾收集器。就是 Serial 收集器的多线程版本
* Parallel Scavenge 收集器：新生代垃圾收集器。多线程收集，功能和 ParNew 类似，与其他收集器不同，该收集器的目标是达到一个可控制的吞吐量。
  - 吞吐量= 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)
  - 吞吐量优先的收集器，可以开启自适应策略，由虚拟机根据当前系统的运行情况动态调整新生代大小、Eden 与 Survivor 区的比例、晋升老年代对象的年龄等信息。自适应调节策略是 Parallel Scavenge 和 ParNew 收集器的一个重要区别。
* Parallel Old 收集器：老年代收集器。使用多线程和 “标记-整理” 算法。是 Parallel Scavenge 收集器的老年代版本。
* CMS （Concurrent Mark Sweep）收集器：老年代收集器。以获取最短回收停顿时间为目标，采用 标记-清除 算法，整个过程基于下面 4 个步骤：
    - 初始标记（CMS initial mark）
    - 并发标记（CMS concurrent mark）
    - 重新标记（CMS remark）
    - 并发清除（CMS concurrent sweep）
    - 在上面的四个步骤中，初始标记、重新标记两个步骤仍然需要 Stop The World，初始标记阶段知识标记一下 GC Roots 能直接关联到的对象，速度很快，重新标记是为了修正并发标记期间由于用户程序继续运行而导致标记产生变动的那一部分对象记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但是远比并发标记的时间短
    - 缺点：1. 对 CPU 资源敏感 2. 无法处理浮动垃圾，可能出现 Concurrent Mode Failure 导致另一次 Full GC 3. 基于标记-清除法可能产生内存碎片
* G1 收集器（Grabage-First） 收集器。将整个 Java 堆划分为多个大小相等的独立区域（Region），跟踪每个 Region 里面垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值最大的 Region。

新生代收集器一般采用复制算法，老年代采用标记整理或者标记清除算法

## 内存分配和回收策略
* 对象优先在 Eden 分配：大多数情况下，对象在新生代 Eden 区中分配。当 Eden 中没有足够空间进行分配时，就进行一次 Minor GC。Mionr GC 十分频繁，回收速度也比较快。
* 大对象直接进入老年代：虚拟机提供了一个 -XX:PretenureSizeThreshold 的参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 和两个 Survivor 区间发生大量的内存复制。
* 长期存活的对象进入老年代：对象在 Survivor 区中没经过一次 Minor GC，年龄就增加 1 岁，当年龄超过一定程度（默认是 15 岁），就会晋升到老年代中。通过设置 -XX:MaxTeruringThreshold 可以设置默认年龄。为了适应不同程度的内存状况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才晋升到老年代，如果在 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象可以直接进入老年代。
* Minor GC 是，Survivor 中无法容纳的对象直接进入老年代。

## 类加载机制
类从被加载到虚拟机内存中，到卸载出内存为止，它的整个生命周期包括下面几个阶段：
* 加载（Loading）：在加载阶段虚拟机需要完成下面 3 件事情：
    - 通过类的一个全限定名来获取定义此类的二进制字节流
    - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    - 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口
    - 用户应用程序可以通过自定义类加载器参与当前过程
* 验证（Verfication）：验证是连接阶段的第一步，主要目的是为了确保 Class 文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
* 准备（Preparation）：准备是正式为类变量（static 变量）分配内存并设置变量初始值的阶段，这些变量所使用的内存都将在方法区中分配
* 解析（Resolution）：虚拟机将常量池中的符号引用替换为直接引用的过程。
* 初始化（Initialization）：是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。
* 使用（Using）
* 卸载（Unloading）

![](/images/java/classload.jpg)

## 类加载器
对于任意一个类，都需要加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。

从 Java 虚拟机的角度来说，只有两种不同的类加载器：一种是启动类加载器，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机。
从开发的人员的角度来看，类加载器可以划分的更细致一些，绝大部分 Java 程序都会使用到下面 3 种系统提供的类加载器：
* 启动类加载器：加载 <JAVA_HOME>\lib 目录下的特定名称类库，例如 rt.jar，无法被 Java 直接使用，如果需要把加载请求委托给引导类加载器，直接使用 null 代替即可。
* 扩展类加载器: 加载 <JAVA_HOME>\lib\ext 目录下的所有类库
* 应用程序类加载器： 加载用户 ClassPath 上所指定的类库

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应用有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承来实现，而是通过组合的关系来复用父加载器的代码。当一个类加载器收到了类加载的请求时，会首先将请求委派给父类加载器去完成，每一个层次的类加载器都是如此，只有父类加载器无法加载该类时，子加载器才会尝试自己去加载。
