# 索引

<!-- toc -->

## 高效使用索引
* 取值时不要使用表达式
* 对于某些数据量大的字段，对该字段创建索引开销较大，可以考虑使用该列的前缀创建索引，前缀的长度应保证尽可能的小并且有足够的区分度，选择前缀长度的一种方法是计算出完整列的区分度，然后保证前缀的区分度和完整列的区分度基本相同就可以了。注意前缀索引不能用于 orderby 或者 groupby，
    ```sql
    # 计算完整列的区分度
    SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
    # 计算不同前缀的区分度
    SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3,
    COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4,
    COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5,  
    COUNT(DISTINCT LEFT(city, 6))/COUNT(*) AS sel6,    
    COUNT(DISTINCT LEFT(city, 7))/COUNT(*) AS sel7    
    FROM sakila.city_demo;
    ```
    ```sql
    # 创建前缀索引
    ALTER TABLE sakila.city_demo ADD KEY (city(7));
    ```
*  聚簇索引将数据存到到叶子节点中，一个表只能有一个聚簇索引，索引值为主键。二级索引中（非聚簇索引）只保存主键的值，因为对于二级索引需要查找两次，第一次在二级索引中找到对应的主键值，第二次根据主键值在聚簇索引中找到记录。
* 如果索引包含了查询所需要的所有数据，我们将其成为覆盖索引. mysql 索引不支持 like 操作（不知道现在的版本支不支持），但是可以进行最左前缀匹配的 like 比较，因为可以将其转为普通的比较操作，但是如果是以通配符开头的 like 比较，mysql 无法支持。Mysql 5.6 之后支持索引过滤了。
  ```sql
  # 无法使用索引
  SELECT * FROM products WHERE actor='SEAN CARREY' AND title like '%APOLLO%'
  # 创建（actor, title, prod_id）的索引，然后改成下面的方式(这里没太懂，后面再看看)
  SELECT * FROM products
  JOIN (SELECT prod_id FROM products WHERE actor='SEAN CARREY' AND title LIKE '%APOLLO%')
  AS t1 ON (t1.prod_id=products.prod_id)
  ```
